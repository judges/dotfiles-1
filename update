#!/bin/sh

warn() {
  echo "==> $*"
}

# Create and clean up temporary files.
trap 'rm $tmp $expected' EXIT
tmp=$(mktemp /tmp/etcupdate.XXXXXXX) || exit 1
expected=$(mktemp /tmp/etcupdate.XXXXXXX) || exit 1

unset force quiet verbose
while getopts fqv opt; do
  case "$opt" in
    f) force=1 ;;
    q) quiet=1 ;;
    v) verbose=1 ;;
    ?) exit ;;
  esac
done

# Find all non-directory files whose names (and parent directories' names)
# don't begin with a dot. Use sed to strip the leading "./". Assumes no spaces
# in filenames.
files=$(find . -name '.[^.]*' -prune -o -not -type d -print | sed -e 's}^\./}}')
for file in $files; do
  test $file = IGNORE -o $file = $(basename $0) && continue
  target="$HOME/.$file"
  echo $target >>"$expected"

  # Ensure the target directory exists.
  targetd=$(dirname $target)
  test -d $targetd || mkdir -p $targetd

  # If the target exists and is correctly linked, go on to the next file. If it
  # exists but doesn't match the source file and -f was not given, display a
  # warning (and the diff, if -v was given) and go on to the next file.
  if [ -e $target ]; then
    test $target -ef $file && continue
    if [ -z "$force" ] && ! cmp -s $file $target; then
      warn ".$file is stale"
      test -n "$verbose" && diff -u $target $file
      continue
    fi
  fi

  # Create the link.
  ln -fv $file $target
done

# Check for extra files in $HOME and display them.
if [ -z "$quiet" ]; then
  sort "$expected" >"$tmp" && cp "$tmp" "$expected"
  find "$HOME"/.[^.]* -not -type d | fgrep -vf IGNORE | sort >"$tmp"
  if ! cmp -s "$tmp" "$expected"; then
    warn 'Extra files:'
    comm -23 "$tmp" "$expected"
  fi
fi
