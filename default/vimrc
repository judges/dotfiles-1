set autoindent
set backspace=2
set backupdir=~/.vim/backup,.
set cinoptions=:0
set confirm
set diffopt+=iwhite
set directory=~/.vim/backup//,.
set expandtab
set hidden
set nohlsearch
set incsearch
set linebreak
set listchars=tab:[-,trail:_,extends:>,precedes:<
set pastetoggle=<F1>
set report=0
set noruler
set showbreak=+
set shiftwidth=4
set shortmess=fnrxotTI
set smarttab
set textwidth=79
set title
set viminfo=""
set whichwrap=""
set wildmode=list:longest

let mapleader = ","
let g:fuzzy_ignore = "*.pyc"

if has("syntax")
    filetype plugin indent on
    syntax on
    "highlight Comment cterm=bold
    "highlight MatchParen ctermbg=blue guibg=lightblue
    "highlight Search ctermfg=black ctermbg=green guibg=green
    "highlight PmenuSel ctermfg=black ctermbg=white

    let g:pyindent_open_paren = '&sw'
    let g:pyindent_continue = '&sw'
    let g:is_bash = 1
endif

if has("gui_running")
    colorscheme macvim
    set bg=dark
    highlight Comment guifg=#666699
    set guicursor+=a:blinkwait0
    set guifont=Consolas:h12
    set guioptions=aegimt
    set lines=40
    set columns=80
endif

if has("autocmd")
    au FileType hog setl textwidth=0
    au FileType make setl noexpandtab shiftwidth=8
    au FileType css,html,htmldjango,xhtml setl shiftwidth=2
    au FileType mail setl textwidth=72
    au FileType nerdtree nmap <buffer> <Enter> o
    au BufNewFile,BufRead /tmp/mutt-* setfiletype mail
    au BufNewFile,BufRead /tmp/mutt-* set notitle
endif

" I never want to run man from inside vim.
map <silent> K k
" Y should act like D or C.
nmap Y y$
" And I don't want LeftMouse to reposition the cursor.
map <LeftMouse> <Nop>
imap <LeftMouse> <Nop>

map <silent> <C-H> :set hlsearch!<CR>
map <silent> <C-J> :bnext<CR>
map <silent> <C-K> :bprevious<CR>
map <silent> <C-N> :cnext<CR>
map <silent> <C-P> :cprevious<CR>
" Bently-style indentation.
map <silent> <leader>b :setlocal sw=2 ts=2 noet<CR>
map <silent> <Leader>e :FuzzyFinderTextMate<CR>
" Prompt to open a file in the same directory as the current buffer's file.
map <silent> <Leader>E :e <C-R>=expand("%:p:h") . "/"<CR>
map <silent> <Leader>f :FuzzyFinderBuffer<CR>
map <silent> <Leader>l :set list!<CR>
map <silent> <Leader>p :set paste!<CR>
" Easily edit the contents of the q register (what I use for macros).
map <silent> <Leader>qp mqGo<ESC>"qp
map <silent> <Leader>qd "qdd`q
" Refresh fuzzyfinder_textmate cache.
map <silent> <Leader>r :ruby finder.rescan!<CR>
map <silent> <Leader>s :set spell!<CR>
" Remove trailing whitespace.
map <silent> <leader>S mS:%s/\s\s*$//<CR>`S
map <silent> <Leader>t :NERDTreeToggle<CR>
" Underline current line.
map <silent> <Leader>u yypv$r-
map <silent> <Leader>U yypv$r=
map <silent> <Leader>v :set columns=161<CR>:vsplit<CR>
map <silent> <Leader>V :close<CR>:set columns=80<CR>
map <silent> <Leader>w :set wrap!<CR>
" Unix timestamp.
iabbr <Leader><Leader>s <C-R>=strftime('%s')<CR>

if exists(":function")
    function! ToggleWrap()
        set linebreak!
        if &showbreak == ''
            let &showbreak = g:old_showbreak
        else
            let g:old_showbreak = &showbreak
            let &showbreak = ''
        endif
    endfunction
    map <silent> <Leader>w :call ToggleWrap()<CR>

    " Hitting tab at the beginning of a line indents; elsewhere completes.
    function! InsertTabWrapper()
        let col = col('.') - 1
        if !col || getline('.')[col - 1] !~ '\k'
            return "\<tab>"
        else
            return "\<c-n>"
        endif
    endfunction
    inoremap <Tab> <C-R>=InsertTabWrapper()<CR>
endif

" Hooray backslashes.
set grepprg=find\ .\ \\!\ -path\ '*.svn/*'\ \\!\ -type\ d\ -print0\ \\\|\ xargs\ -0\ egrep\ -nHI
if has("user_commands")
    command! -nargs=+ -complete=tag G :grep <args>
endif

let NERDTreeIgnore = ['\.pyc$']
let NERDTreeBookmarksFile = $HOME . '/.local/NERDTreeBookmarks'
let NERDTreeQuitOnOpen = 1
